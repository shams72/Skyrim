import { connections } from '../data/connections';

/*************************************************************************************************
 *                                                                                               *
 *  IMPORTANT:                                                                                   *
 *                                                                                               *
 *  THIS CODE IS PURELY FOR TESTING PURPOSES ON THE FRONTEND.                                    *
 *  THE FUNCTIONALITY PROVIDED HERE, INCLUDING PATHFINDING LOGIC AND DATA SOURCES, MUST          *
 *  BE REPLACED WITH BACKEND API                                                                 *
 *                                                                                               *
 *************************************************************************************************/

// util function: creates a weighted adjacency list from the connections
function createWeightedGraph(connections) {
    const graph = {};
    connections.forEach(({ parent, child, dist }) => {
        if (!graph[parent]) graph[parent] = [];
        graph[parent].push({ city: child, distance: dist });
    });
    return graph;
}

// dijkstra's algorithm for finding the optimal path (GENERATED BY GITHUB COPILOT)
function findOptimalPath(graph, start, end) {
    const distances = {};
    const previous = {};
    const visited = new Set();
    const priorityQueue = [{ city: start, distance: 0 }];

    for (let city in graph) {
        distances[city] = Infinity;
    }
    distances[start] = 0;

    while (priorityQueue.length > 0) {
        priorityQueue.sort((a, b) => a.distance - b.distance);
        const { city, distance } = priorityQueue.shift();

        if (visited.has(city)) continue;
        visited.add(city);

        if (city === end) {
            const path = [];
            let current = city;
            while (current) {
                path.unshift(current);
                current = previous[current];
            }
            return { path, visited: Array.from(visited) };
        }

        for (let neighbor of graph[city]) {
            const newDistance = distance + neighbor.distance;
            if (newDistance < distances[neighbor.city]) {
                distances[neighbor.city] = newDistance;
                previous[neighbor.city] = city;
                priorityQueue.push({
                    city: neighbor.city,
                    distance: newDistance,
                });
            }
        }
    }

    return { path: [], visited: Array.from(visited) };
}

// alternative path generator using dfs (GENERATED BY GITHUB COPILOT)
function findAlternativePath(graph, start, end) {
    const visited = new Set();
    const path = [];

    function dfs(current) {
        if (current === end) {
            path.push(current);
            return true;
        }

        visited.add(current);
        path.push(current);

        for (let neighbor of graph[current]) {
            if (!visited.has(neighbor.city)) {
                if (dfs(neighbor.city)) {
                    return true;
                }
            }
        }

        path.pop();
        return false;
    }

    dfs(start);

    return { path, visited: Array.from(visited) };
}

// main pathfinding function
export function pathfinding(start, end) {
    const graph = createWeightedGraph(connections);
    const optimal = findOptimalPath(graph, start, end);
    const alternative = findAlternativePath(graph, start, end);

    return {
        optimalPath: optimal.path,
        optimalVisited: optimal.visited,
        alternativePath: alternative.path,
        alternativeVisited: alternative.visited,
    };
}
